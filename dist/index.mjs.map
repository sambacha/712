{"version":3,"file":"index.mjs","sources":["../src/EIP712Signer.ts"],"sourcesContent":["/**\n * @package EIP712Signer\n * @version 0.1.0\n * @license Apache-20\n * @documentation {@link https://docs.manifoldfinance.com/eip712}\n */\nimport { utils } from 'ethers';\nimport BN from 'bn.js';\n\n/**\n *\n * Field in a User Defined Types\n * @export\n * @interface EIP712StructField\n */\nexport interface EIP712StructField {\n  name: string;\n  type: string;\n}\n\n/**\n * User Defined Types are just an array of the fields they contain\n */\nexport type EIP712Struct = EIP712StructField[];\n\n/**\n *\n *  Interface of the EIP712Domain structure\n * @export\n * @interface EIP712Domain\n */\nexport interface EIP712Domain {\n  name: string;\n  version: string;\n  chainId: number | BN;\n  verifyingContract: string;\n}\n\n/**\n *\n *  Interface of the complete payload required for signing\n * @export\n * @interface EIP712Payload\n */\nexport interface EIP712Payload {\n  types: {\n    [key: string]: EIP712Struct;\n  };\n  primaryType: string;\n  message: any;\n  domain: EIP712Domain;\n}\n\nexport interface EIP712Signature {\n  hex: string;\n  v: number;\n  s: string;\n  r: string;\n}\n\n/**\n * EIP712Domain Type, useful as it is always required inside the payload for the signature\n */\nexport const EIP712DomainType = [\n  {\n    name: 'name',\n    type: 'string',\n  },\n  {\n    name: 'version',\n    type: 'string',\n  },\n  {\n    name: 'chainId',\n    type: 'uint256',\n  },\n  {\n    name: 'verifyingContract',\n    type: 'address',\n  },\n];\n\n/**\n * Byte32 zero value\n */\nconst B32Z =\n  '0x0000000000000000000000000000000000000000000000000000000000000000';\n\nexport type ExternalSigner = (\n  encodedPayload: string,\n) => Promise<EIP712Signature>;\n\n/**\n *\n * Helper class that takes types, domain and primary when built and is able to verify provided arguments, sign payload and verify signatures\n * This class should be extended by a custom class.\n * @export\n * @class EIP712Signer\n */\nexport class EIP712Signer {\n  /**\n   * All types of current Signer\n   */\n  private readonly structs: { [key: string]: EIP712Struct } = {\n    EIP712Domain: EIP712DomainType,\n  };\n\n  /**\n   * Mandatory domain structure\n   */\n  private domain: EIP712Domain = {\n    name: undefined || '',\n    version: undefined || '',\n    verifyingContract: undefined || '',\n    chainId: undefined || 0,\n  };\n\n  /**\n   * Required for checks\n   */\n  private readonly REQUIRED_FIELDS: string[] = [\n    'domain',\n    'types',\n    'message',\n    'primaryType',\n  ];\n\n  /**\n   * Adds provided type to type list\n   *\n   * @param name Name of the type\n   * @param struct Fields of the type\n   * @private\n   */\n  private _addType(name: string, struct: EIP712Struct): void {\n    if (this.structs[name] !== undefined) {\n      throw new Error(`Type already exists ${name}`);\n    }\n    this.structs[name] = struct;\n  }\n\n  /**\n   * Sets the domain (EIP712Domain) structure\n   *\n   * @param domain Domain structure\n   * @private\n   */\n  private _setDomain(domain: EIP712Domain): void {\n    this.domain = domain;\n  }\n\n  /**\n   * Encodes a single field. Works by calling itself recursively for complexe types or arrays\n   *\n   * @param type Name of the given field\n   * @param value Value of the given field\n   * @private\n   */\n  private _encodeDataTypeField(type: string, value: any): [string, string] {\n    // If it's a structure type\n    if (this.structs[type]) {\n      return ['bytes32', value === null ? B32Z : this._hashData(type, value)];\n    }\n\n    // If it's bytes or string, hash it\n    if (type === 'bytes') {\n      return ['bytes32', utils.keccak256(value)];\n    }\n\n    // If it's bytes or string, hash it\n    if (type === 'string') {\n      return ['bytes32', utils.keccak256(Buffer.from(value, 'utf8'))];\n    }\n\n    if (type === 'uint256') {\n      if (typeof value === 'object') {\n        value = value.toString();\n      }\n    }\n\n    // If ends by [], it's an array\n    if (type.lastIndexOf('[]') === type.length - 2) {\n      const extracted_type = type.slice(0, type.lastIndexOf('[]'));\n      const encoded_array = value.map((elem: any): [string, string] =>\n        this._encodeDataTypeField(extracted_type, elem),\n      );\n\n      const abie = new utils.AbiCoder();\n\n      return [\n        'bytes32',\n        utils.keccak256(\n          abie.encode(\n            encoded_array.map((elem: [string, string]): string => elem[0]),\n            encoded_array.map((elem: [string, string]): string => elem[1]),\n          ),\n        ),\n      ];\n    }\n\n    // If it arrives here, it means that it's standard type and no manipulations are required\n    return [type, value];\n  }\n\n  /**\n   * Encodes a type and all of its fields. Is often called recursively when dealing with structures inside structures ...\n   *\n   * @param name Name of the type\n   * @param payload Object that is supposed to contain all fields for given type\n   * @private\n   */\n  private _encodeData(name: string, payload: any): string {\n    const encodedTypes: string[] = ['bytes32'];\n    const encodedData: string[] = [this._hashType(name)];\n\n    for (const field of this.structs[name]) {\n      // Check if all fields of type are found\n      if (payload[field.name] === undefined) {\n        throw new Error(\n          `Invalid Payload: at type ${name}, missing field ${field.name}`,\n        );\n      }\n\n      const field_res = this._encodeDataTypeField(\n        field.type,\n        payload[field.name],\n      );\n\n      encodedTypes.push(field_res[0]);\n      encodedData.push(field_res[1]);\n    }\n\n    const abie = new utils.AbiCoder();\n\n    return abie.encode(encodedTypes, encodedData);\n  }\n\n  /**\n   * Applies a keccak256 hash to the result of _encodeData\n   *\n   * @param type Name of the type\n   * @param data Object that is supposed to contain all fields for given type\n   * @private\n   */\n  private _hashData(type: string, data: any): string {\n    return utils.keccak256(this._encodeData(type, data));\n  }\n\n  /**\n   * Recursively finds all the dependencies of given type. Required to encode the type.\n   *\n   * @param type Name of the type\n   * @param met Map that stores types already found in the recursive process\n   * @private\n   */\n  private _getDependenciesOf(type: string, met: any = {}): string[] {\n    let result = [];\n\n    if (type.lastIndexOf('[]') === type.length - 2) {\n      return this._getDependenciesOf(\n        type.slice(0, type.lastIndexOf('[]')),\n        met,\n      );\n    }\n\n    // If type already found or is not a struct type, stop recursive process\n    if (met[type] === true || this.structs[type] === undefined) return result;\n// @ts-ignore\n    result.push(type);\n    met[type] = true;\n\n    for (const field of this.structs[type]) {\n        // @ts-ignore\n      result = result.concat(this._getDependenciesOf(field.type, met));\n    }\n\n    return result;\n  }\n\n  /**\n   * Taking all types, getting all dependencies, putting main type first then all the rest\n   * sorted. 100% Inspired by what was done in eth-sig-util\n   *\n   * @param type\n   * @private\n   */\n  private _encodeType(type: string): string {\n    let result: string = '';\n    let dependencies = this._getDependenciesOf(type)\n      .filter((dep: string): boolean => dep !== type)\n      .sort();\n    dependencies = [type].concat(dependencies);\n\n    for (const t of dependencies) {\n      result += `${t}(${this.structs[t]\n        .map(\n          (struct: EIP712StructField): string =>\n            `${struct.type} ${struct.name}`,\n        )\n        .join(',')})`;\n    }\n\n    return result;\n  }\n\n  /**\n   * Applies a keccak256 hash to the result of _encodeType\n   *\n   * @param type Name of the type\n   * @private\n   */\n  private _hashType(type: string): string {\n    return utils.keccak256(Buffer.from(this._encodeType(type)));\n  }\n\n  /**\n   * Helper that verifies the types field on the provided payload\n   *\n   * @param payload Payload to verify\n   * @private\n   */\n  private _verifyTypes(payload: EIP712Payload): void {\n    const primary_type_dependencies = this._getDependenciesOf(\n      payload.primaryType,\n    );\n    const required_types = {\n      EIP712Domain: this.structs['EIP712Domain'],\n    };\n\n    for (const dep of primary_type_dependencies) {\n      required_types[dep] = this.structs[dep];\n    }\n\n    if (\n      Object.keys(payload.types).length !== Object.keys(required_types).length\n    ) {\n      throw new Error(\n        `Invalid Types in given payload: got ${Object.keys(\n          payload.types,\n        )}, expect ${Object.keys(required_types)}`,\n      );\n    }\n\n    for (const type of Object.keys(payload.types)) {\n      if (!this.structs[type]) throw new Error(`Unknown type ${type}`);\n\n      const current_type = payload.types[type];\n      const registered_current_type = this.structs[type];\n\n      for (const field of current_type) {\n        const eq_idx = registered_current_type.findIndex(\n          (eq_field: EIP712StructField): boolean =>\n            eq_field.name === field.name,\n        );\n\n        if (eq_idx === -1)\n          throw new Error(\n            `Error in ${type} type: unknwon field with name ${field.name}`,\n          );\n\n        if (field.type !== registered_current_type[eq_idx].type)\n          throw new Error(\n            `Error in ${type} type: mismatch in field types: got ${field.type}, expected ${registered_current_type[eq_idx].type}`,\n          );\n      }\n    }\n  }\n\n  /**\n   * Helper that verifies the domain field on the provided payload\n   *\n   * @param payload Payload to verify\n   * @private\n   */\n  private _verifyDomain(payload: EIP712Payload): void {\n    for (const field of this.structs['EIP712Domain']) {\n      if (payload.domain[field.name] === undefined)\n        throw new Error(`Missing field in domain: ${field.name}`);\n    }\n  }\n\n  /**\n   * Helper that verifies the primaryType field on the provided payload\n   *\n   * @param payload Payload to verify\n   * @private\n   */\n  private _verifyPrimaryType(payload: EIP712Payload): void {\n    if (!this.structs[payload.primaryType]) {\n      throw new Error(\n        `Invalid primary type ${payload.primaryType}: unknown type`,\n      );\n    }\n  }\n\n  /**\n   * Helper that verifies that all required fields are present\n   *\n   * @param payload Payload to verify\n   * @private\n   */\n  private _verifyMainPayloadField(payload: EIP712Payload): void {\n    if (Object.keys(payload).length !== this.REQUIRED_FIELDS.length) {\n      throw new Error(\n        `Invalid payload: has fields ${Object.keys(payload)}, should have ${\n          this.REQUIRED_FIELDS\n        }`,\n      );\n    }\n\n    for (const req of this.REQUIRED_FIELDS) {\n      if (!Object.keys(payload).includes(req)) {\n        throw new Error(`Missing ${req} field in payload`);\n      }\n    }\n  }\n\n  /**\n   * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n   *\n   * @param num Signed integer value\n   */\n  private _fromSigned(num: string): BN {\n    return new BN(Buffer.from(num.slice(2), 'hex')).fromTwos(256);\n  }\n\n  /**\n   * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n   *\n   * @param num\n   */\n  private _toUnsigned(num: BN): Buffer {\n    return Buffer.from(num.toTwos(256).toArray());\n  }\n\n  /**\n   * Pads provided string value to match provided length value.\n   *\n   * @param toPad Starting string to pad\n   * @param length Target length\n   * @private\n   */\n  private static _padWithZeroes(toPad: string, length: number): string {\n    let myString = '' + toPad;\n    while (myString.length < length) {\n      myString = '0' + myString;\n    }\n    return myString;\n  }\n\n  /********** PUBLIC INTERFACE ***********/\n\n  /**\n   * Sets all information related to the signatures that will be generated.\n   *\n   * @param domain Domain structure\n   * @param primary_type Primary Type to use\n   * @param types Arrays containing name and fields\n   */\n  public constructor(domain: EIP712Domain, ...types: [string, EIP712Struct][]) {\n    this._setDomain(domain);\n    for (const type of types) {\n      this._addType(type[0], type[1]);\n    }\n  }\n\n  /**\n   * Throws if provided payload does not match current settings\n   *\n   * @param payload Payload to verify\n   */\n  public verifyPayload(payload: EIP712Payload): void {\n    this._verifyMainPayloadField(payload);\n    this._verifyTypes(payload);\n    this._verifyDomain(payload);\n    this._verifyPrimaryType(payload);\n    void this.encode(payload);\n  }\n\n  /**\n   * Encode the given payload\n   *\n   * @param payload Payload to encode\n   * @param verify True if verifications should be made\n   */\n  public encode(payload: EIP712Payload, verify: boolean = false): string {\n    this._verifyMainPayloadField(payload);\n\n    if (verify) {\n      this._verifyTypes(payload);\n      this._verifyDomain(payload);\n      this._verifyPrimaryType(payload);\n    }\n\n    // Magic Number\n    const result = [Buffer.from('1901', 'hex')];\n\n    result.push(\n      Buffer.from(\n        this._hashData('EIP712Domain', payload.domain).slice(2),\n        'hex',\n      ),\n    );\n\n    if (payload.primaryType !== 'EIP712Domain') {\n      result.push(\n        Buffer.from(\n          this._hashData(payload.primaryType, payload.message).slice(2),\n          'hex',\n        ),\n      );\n    }\n\n    return `0x${Buffer.concat(result).toString('hex')}`;\n  }\n\n  /**\n   * Sign the given payload\n   *\n   * @param privateKey Private key to use\n   * @param payload Payload to sign\n   * @param verify True if verifications should be made\n   */\n  public async sign(\n    privateKey: string | ExternalSigner,\n    payload: EIP712Payload,\n    verify: boolean = false,\n  ): Promise<EIP712Signature> {\n    const encoded_payload = this.encode(payload, verify);\n\n    switch (typeof privateKey) {\n      case 'string': {\n        const sk = new utils.SigningKey(privateKey);\n\n        const hashed_payload = utils.keccak256(\n          Buffer.from(encoded_payload.slice(2), 'hex'),\n        );\n        const signature = sk.signDigest(\n          Buffer.from(hashed_payload.slice(2), 'hex'),\n        );\n\n        const rSig = this._fromSigned(signature.r);\n        const sSig = this._fromSigned(signature.s);\n        const vSig = signature.v;\n        const rStr = EIP712Signer._padWithZeroes(\n          this._toUnsigned(rSig).toString('hex'),\n          64,\n        );\n        const sStr = EIP712Signer._padWithZeroes(\n          this._toUnsigned(sSig).toString('hex'),\n          64,\n        );\n        const vStr = vSig.toString(16);\n\n        return {\n          hex: `0x${rStr}${sStr}${vStr}`,\n          v: vSig,\n          r: rStr,\n          s: sStr,\n        };\n      }\n\n      case 'function': {\n        return privateKey(encoded_payload);\n      }\n    }\n  }\n\n  /**\n   * Verifies the given signature\n   *\n   * @param payload Payload used to generate the signature\n   * @param signature Signature to verify\n   * @param verify True if payload verifications should be made\n   */\n  public async verify(\n    payload: EIP712Payload,\n    signature: string,\n    verify: boolean = false,\n  ): Promise<string> {\n    const encoded_payload = this.encode(payload, verify);\n    const hashed_payload = utils.keccak256(\n      Buffer.from(encoded_payload.slice(2), 'hex'),\n    );\n\n    return utils.recoverAddress(\n      Buffer.from(hashed_payload.slice(2), 'hex'),\n      signature,\n    );\n  }\n\n  /**\n   * Helper that generates a complete payload, ready for signature (should work with web3, metamask etc)\n   *\n   * @param data Message field in the generated payload\n   * @param primaryType Main type of given data\n   */\n  public generatePayload(data: any, primaryType: string): EIP712Payload {\n    const dependencies = this._getDependenciesOf(primaryType);\n    const types = {};\n\n    for (const dep of dependencies) {\n      types[dep] = this.structs[dep];\n    }\n\n    types['EIP712Domain'] = this.structs['EIP712Domain'];\n\n    return {\n      domain: this.domain,\n      primaryType,\n      types,\n      message: data,\n    };\n  }\n}\n/** @exports EIP712Signer */\n"],"names":[],"mappings":";;;AAAA,IAAI,OAAO,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,KAAK;AAClD,EAAE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AAC1C,IAAI,IAAI,SAAS,GAAG,CAAC,KAAK,KAAK;AAC/B,MAAM,IAAI;AACV,QAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;AACpC,OAAO,CAAC,OAAO,CAAC,EAAE;AAClB,QAAQ,MAAM,CAAC,CAAC,CAAC,CAAC;AAClB,OAAO;AACP,KAAK,CAAC;AACN,IAAI,IAAI,QAAQ,GAAG,CAAC,KAAK,KAAK;AAC9B,MAAM,IAAI;AACV,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AACrC,OAAO,CAAC,OAAO,CAAC,EAAE;AAClB,QAAQ,MAAM,CAAC,CAAC,CAAC,CAAC;AAClB,OAAO;AACP,KAAK,CAAC;AACN,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;AACrG,IAAI,IAAI,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,WAAW,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;AACpE,GAAG,CAAC,CAAC;AACL,CAAC,CAAC;AASU,MAAC,gBAAgB,GAAG;AAChC,EAAE;AACF,IAAI,IAAI,EAAE,MAAM;AAChB,IAAI,IAAI,EAAE,QAAQ;AAClB,GAAG;AACH,EAAE;AACF,IAAI,IAAI,EAAE,SAAS;AACnB,IAAI,IAAI,EAAE,QAAQ;AAClB,GAAG;AACH,EAAE;AACF,IAAI,IAAI,EAAE,SAAS;AACnB,IAAI,IAAI,EAAE,SAAS;AACnB,GAAG;AACH,EAAE;AACF,IAAI,IAAI,EAAE,mBAAmB;AAC7B,IAAI,IAAI,EAAE,SAAS;AACnB,GAAG;AACH,EAAE;AACF,MAAM,IAAI,GAAG,oEAAoE,CAAC;AAC3E,MAAM,YAAY,CAAC;AAC1B,EAAE,WAAW,CAAC,MAAM,EAAE,GAAG,KAAK,EAAE;AAChC,IAAI,IAAI,CAAC,OAAO,GAAG;AACnB,MAAM,YAAY,EAAE,gBAAgB;AACpC,KAAK,CAAC;AACN,IAAI,IAAI,CAAC,MAAM,GAAG;AAClB,MAAM,IAAI,EAAE,EAAE;AACd,MAAM,OAAO,EAAE,EAAE;AACjB,MAAM,iBAAiB,EAAE,EAAE;AAC3B,MAAM,OAAO,EAAE,CAAC;AAChB,KAAK,CAAC;AACN,IAAI,IAAI,CAAC,eAAe,GAAG;AAC3B,MAAM,QAAQ;AACd,MAAM,OAAO;AACb,MAAM,SAAS;AACf,MAAM,aAAa;AACnB,KAAK,CAAC;AACN,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;AAC5B,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AAC9B,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,KAAK;AACL,GAAG;AACH,EAAE,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE;AACzB,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;AACvC,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AACrD,KAAK;AACL,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC;AAChC,GAAG;AACH,EAAE,UAAU,CAAC,MAAM,EAAE;AACrB,IAAI,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACzB,GAAG;AACH,EAAE,oBAAoB,CAAC,IAAI,EAAE,KAAK,EAAE;AACpC,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC5B,MAAM,OAAO,CAAC,SAAS,EAAE,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;AAC9E,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,OAAO,EAAE;AAC1B,MAAM,OAAO,CAAC,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AACjD,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,QAAQ,EAAE;AAC3B,MAAM,OAAO,CAAC,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;AACtE,KAAK;AACL,IAAI,IAAI,IAAI,KAAK,SAAS,EAAE;AAC5B,MAAM,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;AACrC,QAAQ,KAAK,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;AACjC,OAAO;AACP,KAAK;AACL,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;AACpD,MAAM,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;AACnE,MAAM,MAAM,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,oBAAoB,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC,CAAC;AACjG,MAAM,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;AACxC,MAAM,OAAO;AACb,QAAQ,SAAS;AACjB,QAAQ,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChH,OAAO,CAAC;AACR,KAAK;AACL,IAAI,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACzB,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE,OAAO,EAAE;AAC7B,IAAI,MAAM,YAAY,GAAG,CAAC,SAAS,CAAC,CAAC;AACrC,IAAI,MAAM,WAAW,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;AAC/C,IAAI,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC5C,MAAM,IAAI,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,EAAE;AAC1C,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,yBAAyB,EAAE,IAAI,CAAC,gBAAgB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACzF,OAAO;AACP,MAAM,MAAM,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;AACnF,MAAM,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,MAAM,WAAW,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACrC,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;AACtC,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC;AAClD,GAAG;AACH,EAAE,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE;AACxB,IAAI,OAAO,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AACzD,GAAG;AACH,EAAE,kBAAkB,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE;AACrC,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;AACpD,MAAM,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACjF,KAAK;AACL,IAAI,IAAI,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC;AAC3D,MAAM,OAAO,MAAM,CAAC;AACpB,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACtB,IAAI,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AACrB,IAAI,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AAC5C,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AACvE,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,GAAG;AACH,EAAE,WAAW,CAAC,IAAI,EAAE;AACpB,IAAI,IAAI,MAAM,GAAG,EAAE,CAAC;AACpB,IAAI,IAAI,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,KAAK,GAAG,KAAK,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;AAC1F,IAAI,YAAY,GAAG,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;AAC/C,IAAI,KAAK,MAAM,CAAC,IAAI,YAAY,EAAE;AAClC,MAAM,MAAM,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACtG,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,GAAG;AACH,EAAE,SAAS,CAAC,IAAI,EAAE;AAClB,IAAI,OAAO,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAChE,GAAG;AACH,EAAE,YAAY,CAAC,OAAO,EAAE;AACxB,IAAI,MAAM,yBAAyB,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACnF,IAAI,MAAM,cAAc,GAAG;AAC3B,MAAM,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC;AAChD,KAAK,CAAC;AACN,IAAI,KAAK,MAAM,GAAG,IAAI,yBAAyB,EAAE;AACjD,MAAM,cAAc,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,EAAE;AAClF,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,oCAAoC,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;AAClI,KAAK;AACL,IAAI,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACnD,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;AAC7B,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AAChD,MAAM,MAAM,YAAY,GAAG,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;AAC/C,MAAM,MAAM,uBAAuB,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;AACzD,MAAM,KAAK,MAAM,KAAK,IAAI,YAAY,EAAE;AACxC,QAAQ,MAAM,MAAM,GAAG,uBAAuB,CAAC,SAAS,CAAC,CAAC,QAAQ,KAAK,QAAQ,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC;AACrG,QAAQ,IAAI,MAAM,KAAK,CAAC,CAAC;AACzB,UAAU,MAAM,IAAI,KAAK,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,+BAA+B,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1F,QAAQ,IAAI,KAAK,CAAC,IAAI,KAAK,uBAAuB,CAAC,MAAM,CAAC,CAAC,IAAI;AAC/D,UAAU,MAAM,IAAI,KAAK,CAAC,CAAC,SAAS,EAAE,IAAI,CAAC,oCAAoC,EAAE,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,uBAAuB,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACjJ,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,aAAa,CAAC,OAAO,EAAE;AACzB,IAAI,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;AACtD,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC;AAC/C,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,yBAAyB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClE,KAAK;AACL,GAAG;AACH,EAAE,kBAAkB,CAAC,OAAO,EAAE;AAC9B,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;AAC5C,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,qBAAqB,EAAE,OAAO,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC;AACnF,KAAK;AACL,GAAG;AACH,EAAE,uBAAuB,CAAC,OAAO,EAAE;AACnC,IAAI,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,KAAK,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE;AACrE,MAAM,MAAM,IAAI,KAAK,CAAC,CAAC,4BAA4B,EAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,cAAc,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AAClH,KAAK;AACL,IAAI,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,eAAe,EAAE;AAC5C,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AAC/C,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,QAAQ,EAAE,GAAG,CAAC,iBAAiB,CAAC,CAAC,CAAC;AAC3D,OAAO;AACP,KAAK;AACL,GAAG;AACH,EAAE,WAAW,CAAC,GAAG,EAAE;AACnB,IAAI,OAAO,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AAClE,GAAG;AACH,EAAE,WAAW,CAAC,GAAG,EAAE;AACnB,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;AAClD,GAAG;AACH,EAAE,OAAO,cAAc,CAAC,KAAK,EAAE,MAAM,EAAE;AACvC,IAAI,IAAI,QAAQ,GAAG,EAAE,GAAG,KAAK,CAAC;AAC9B,IAAI,OAAO,QAAQ,CAAC,MAAM,GAAG,MAAM,EAAE;AACrC,MAAM,QAAQ,GAAG,GAAG,GAAG,QAAQ,CAAC;AAChC,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC;AACpB,GAAG;AACH,EAAE,aAAa,CAAC,OAAO,EAAE;AACzB,IAAI,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;AAC1C,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;AAC/B,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;AAChC,IAAI,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;AACrC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;AAC9B,GAAG;AACH,EAAE,MAAM,CAAC,OAAO,EAAE,MAAM,GAAG,KAAK,EAAE;AAClC,IAAI,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;AAC1C,IAAI,IAAI,MAAM,EAAE;AAChB,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;AACjC,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;AAClC,MAAM,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;AACvC,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;AAChD,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AAC7F,IAAI,IAAI,OAAO,CAAC,WAAW,KAAK,cAAc,EAAE;AAChD,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AACrG,KAAK;AACL,IAAI,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACxD,GAAG;AACH,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,EAAE,MAAM,GAAG,KAAK,EAAE;AAC5C,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,aAAa;AAC5C,MAAM,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC3D,MAAM,QAAQ,OAAO,UAAU;AAC/B,QAAQ,KAAK,QAAQ,EAAE;AACvB,UAAU,MAAM,EAAE,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AACtD,UAAU,MAAM,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AAC/F,UAAU,MAAM,SAAS,GAAG,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AACvF,UAAU,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACrD,UAAU,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACrD,UAAU,MAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC;AACnC,UAAU,MAAM,IAAI,GAAG,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;AAC/F,UAAU,MAAM,IAAI,GAAG,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC;AAC/F,UAAU,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AACzC,UAAU,OAAO;AACjB,YAAY,GAAG,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;AAC1C,YAAY,CAAC,EAAE,IAAI;AACnB,YAAY,CAAC,EAAE,IAAI;AACnB,YAAY,CAAC,EAAE,IAAI;AACnB,WAAW,CAAC;AACZ,SAAS;AACT,QAAQ,KAAK,UAAU,EAAE;AACzB,UAAU,OAAO,UAAU,CAAC,eAAe,CAAC,CAAC;AAC7C,SAAS;AACT,OAAO;AACP,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,MAAM,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,GAAG,KAAK,EAAE;AAC7C,IAAI,OAAO,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,aAAa;AAC5C,MAAM,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC3D,MAAM,MAAM,cAAc,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;AAC3F,MAAM,OAAO,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,CAAC;AAC1F,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,eAAe,CAAC,IAAI,EAAE,WAAW,EAAE;AACrC,IAAI,MAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;AAC9D,IAAI,MAAM,KAAK,GAAG,EAAE,CAAC;AACrB,IAAI,KAAK,MAAM,GAAG,IAAI,YAAY,EAAE;AACpC,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;AACrC,KAAK;AACL,IAAI,KAAK,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;AACzD,IAAI,OAAO;AACX,MAAM,MAAM,EAAE,IAAI,CAAC,MAAM;AACzB,MAAM,WAAW;AACjB,MAAM,KAAK;AACX,MAAM,OAAO,EAAE,IAAI;AACnB,KAAK,CAAC;AACN,GAAG;AACH;;;;"}